<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Go的web框架了解 | oort_vuepress</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="oort_vuepress">
    <link rel="preload" href="/oort_vuepress/assets/css/0.styles.ef234786.css" as="style"><link rel="preload" href="/oort_vuepress/assets/js/app.87766072.js" as="script"><link rel="preload" href="/oort_vuepress/assets/js/2.1e38d289.js" as="script"><link rel="preload" href="/oort_vuepress/assets/js/7.792cc8de.js" as="script"><link rel="prefetch" href="/oort_vuepress/assets/js/3.c0064fc2.js"><link rel="prefetch" href="/oort_vuepress/assets/js/4.7ff86de4.js"><link rel="prefetch" href="/oort_vuepress/assets/js/5.97e329f7.js"><link rel="prefetch" href="/oort_vuepress/assets/js/6.6b72ecd4.js"><link rel="prefetch" href="/oort_vuepress/assets/js/8.4ae5890f.js">
    <link rel="stylesheet" href="/oort_vuepress/assets/css/0.styles.ef234786.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/oort_vuepress/" class="home-link router-link-active"><img src="/oort_vuepress/logo.png" alt="oort_vuepress" class="logo"> <span class="site-name can-hide">oort_vuepress</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/oort_vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/oort_vuepress/" class="nav-link">
  文档中心
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/oort_vuepress/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/oort_vuepress/" class="nav-link">
  文档中心
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Go的web框架了解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/oort_vuepress/guide/go/#go的web框架了解" class="sidebar-link">Go的web框架了解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#环境安装" class="sidebar-link">环境安装</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#使用goland-编译第一个go程序" class="sidebar-link">使用goland 编译第一个Go程序</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-语言结构" class="sidebar-link">Go 语言结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-数据类型" class="sidebar-link">Go 数据类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#数字类型" class="sidebar-link">数字类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-语言变量" class="sidebar-link">Go 语言变量</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#import-的特殊语法" class="sidebar-link">import 的特殊语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#变量定义" class="sidebar-link">变量定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#值类型和引用类型" class="sidebar-link">值类型和引用类型</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-语言常量" class="sidebar-link">Go 语言常量</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-语言运算符" class="sidebar-link">Go 语言运算符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-条件-语句" class="sidebar-link">Go 条件 语句</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#循环语句" class="sidebar-link">循环语句</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-函数" class="sidebar-link">Go 函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-变量的作用域" class="sidebar-link">Go 变量的作用域</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-数组" class="sidebar-link">Go 数组</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-指针" class="sidebar-link">Go 指针</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-结构体" class="sidebar-link">Go 结构体</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-切片" class="sidebar-link">Go 切片</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-语言范围" class="sidebar-link">Go 语言范围</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-map-集合" class="sidebar-link">Go Map 集合</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-递归" class="sidebar-link">Go 递归</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-类型转换" class="sidebar-link">Go 类型转换</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-接口" class="sidebar-link">Go 接口</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-错误处理" class="sidebar-link">Go 错误处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-并发" class="sidebar-link">Go 并发</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-内存分配" class="sidebar-link">Go 内存分配</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-的主要特性" class="sidebar-link">GO 的主要特性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go的环境变量" class="sidebar-link">go的环境变量</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-的channel-详解" class="sidebar-link">go 的channel 详解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#go-进阶" class="sidebar-link">go 进阶</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#init-函数详解" class="sidebar-link">init 函数详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oort_vuepress/guide/go/#若只想执行包中的init函数，而不使用包导出的变量和函数-可用-import" class="sidebar-link">若只想执行包中的init函数，而不使用包导出的变量和函数 可用 import _</a></li></ul></li><li><a href="/oort_vuepress/guide/go/#结构体的赋值和初始化" class="sidebar-link">结构体的赋值和初始化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#结构体不能包含自己" class="sidebar-link">结构体不能包含自己</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#interface-的解释" class="sidebar-link">interface{} 的解释</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/oort_vuepress/guide/go/#不同平台go-build-的参数变化" class="sidebar-link">不同平台go build 的参数变化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/oort_vuepress/guide/go/#编译linux" class="sidebar-link">编译linux</a></li><li class="sidebar-sub-header"><a href="/oort_vuepress/guide/go/#编译window" class="sidebar-link">编译window</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="go的web框架了解"><a href="#go的web框架了解" class="header-anchor">#</a> Go的web框架了解</h2> <p><a href="https://blog.csdn.net/dev_csdn/article/details/78740990" target="_blank" rel="noopener noreferrer">csdn Go web 框架对比<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="环境安装"><a href="#环境安装" class="header-anchor">#</a> 环境安装</h2> <h2 id="使用goland-编译第一个go程序"><a href="#使用goland-编译第一个go程序" class="header-anchor">#</a> 使用goland 编译第一个Go程序</h2> <p>package main</p> <p>import &quot;fmt&quot;</p> <p>func main()  {
fmt.Printf(&quot;hello world&quot;)
}】</p> <h2 id="go-语言结构"><a href="#go-语言结构" class="header-anchor">#</a> Go 语言结构</h2> <div class="language- extra-class"><pre><code>- 包声明
- 引入包
- 函数
- 变量
- 语句 &amp; 表达式
- 注释
</code></pre></div><p>注意： Go 语法中 { 不能单独一行</p> <p>##　Go的基础语法</p> <div class="language- extra-class"><pre><code>- Go 标记 关键字 标识符 常量 字符串 符号 等 
- 行分隔符号 一行代表一个语句结束
- 注释
- 标识符
- 字符串连接  可以通过 + 实现
- 关键字
</code></pre></div><h2 id="go-数据类型"><a href="#go-数据类型" class="header-anchor">#</a> Go 数据类型</h2> <div class="language- extra-class"><pre><code>- 布尔  false true
- 数字类型 int  float32  float64 
- 字符串类型
- 派生类型 指针  数组 struct  channel 函数类型 切片类型
	接口类型  Map类型
</code></pre></div><h2 id="数字类型"><a href="#数字类型" class="header-anchor">#</a> 数字类型</h2> <h2 id="go-语言变量"><a href="#go-语言变量" class="header-anchor">#</a> Go 语言变量</h2> <div class="language- extra-class"><pre><code>- 由字母、数字、下划线， 首字母不能为数字
- 声明变量 一般使用var 
</code></pre></div><h2 id="import-的特殊语法"><a href="#import-的特殊语法" class="header-anchor">#</a> import 的特殊语法</h2> <div class="language- extra-class"><pre><code>- 点 . 操作
- 别名操作
- 下划线 _ 操作 导入该包，不导入整个包而是执行包中的init函数，注意init不需要调用就会执行
</code></pre></div><h2 id="变量定义"><a href="#变量定义" class="header-anchor">#</a> 变量定义</h2> <div class="language- extra-class"><pre><code>var variable_list data_type
多变量可以同时赋值操作
:= 表示声明变量并且赋值  #系统自动推断类型,不需要var关键字
特殊变量 &quot;_&quot;  任何赋值 都会别丢弃 具体意义类似 
	_,numb,strs := numbers() //只获取函数返回值的后两个
:= 左侧的变量不应该是已经被声明过的，否则会导致编译错误
</code></pre></div><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="header-anchor">#</a> 值类型和引用类型</h2> <div class="language- extra-class"><pre><code>通过 &amp;i 来获取变量 i 的内存地址
</code></pre></div><p>​</p> <h2 id="go-语言常量"><a href="#go-语言常量" class="header-anchor">#</a> Go 语言常量</h2> <div class="language- extra-class"><pre><code>- const  可以用作枚举
- iota const 中每新增一行常量声明将使 iota 计数一次 第一个 iota 等于 0
</code></pre></div><h2 id="go-语言运算符"><a href="#go-语言运算符" class="header-anchor">#</a> Go 语言运算符</h2> <div class="language- extra-class"><pre><code>- 算术运算符  加减乘除
- 关系运算符   &lt; &gt; &lt;= &gt;= != == 
- 逻辑运算符 &amp;&amp; || ！
- 位运算符 &amp; | ^   &gt;&gt; &lt;&lt; 
- 
- 
</code></pre></div><h2 id="go-条件-语句"><a href="#go-条件-语句" class="header-anchor">#</a> Go 条件 语句</h2> <div class="language- extra-class"><pre><code>-if if...else  
- switch  fallthrough 强行执行之后的case语句
	不同的 case 之间不使用 break 分隔 默认只执行一个case
- select
	select 会循环检测条件，如果有满足则执行并退出，
	否则一直循环检测。
</code></pre></div><h2 id="循环语句"><a href="#循环语句" class="header-anchor">#</a> 循环语句</h2> <div class="language- extra-class"><pre><code>- for   break continue goto
- 实现九九乘法表
</code></pre></div><h2 id="go-函数"><a href="#go-函数" class="header-anchor">#</a> Go 函数</h2> <div class="language- extra-class"><pre><code>- Go 语言最少有个 main() 函数
- 闭包
- 函数作为一个参数
- 函数声明  type cb func(int) int
- 返回多个值
- 不定参数
</code></pre></div><h2 id="go-变量的作用域"><a href="#go-变量的作用域" class="header-anchor">#</a> Go 变量的作用域</h2> <div class="language- extra-class"><pre><code>- 局部变量
- 全局变量
- 形参
</code></pre></div><h2 id="go-数组"><a href="#go-数组" class="header-anchor">#</a> Go 数组</h2> <div class="language- extra-class"><pre><code>- 声明需要指定元素类型及其个数
</code></pre></div><h2 id="go-指针"><a href="#go-指针" class="header-anchor">#</a> Go 指针</h2> <div class="language- extra-class"><pre><code>- 一个指针变量指向了一个值的内存地址。
- 声明指针 var-type 为指针类型
- var p *int 
</code></pre></div><h2 id="go-结构体"><a href="#go-结构体" class="header-anchor">#</a> Go 结构体</h2> <h2 id="go-切片"><a href="#go-切片" class="header-anchor">#</a> Go 切片</h2> <div class="language- extra-class"><pre><code>make函数创建切片 内置类型切片(&quot;动态数组&quot;),

make([]int,3,5)
len = 3 cap = 5

如果要增加切片的容量，必须创建一个新的更大
的切片并把原分片的内容都拷贝过来
</code></pre></div><h2 id="go-语言范围"><a href="#go-语言范围" class="header-anchor">#</a> Go 语言范围</h2> <div class="language- extra-class"><pre><code>range 用于for循环中迭代数组，切片，通道或者map的元素

相当于 for in
</code></pre></div><h2 id="go-map-集合"><a href="#go-map-集合" class="header-anchor">#</a> Go Map 集合</h2> <div class="language- extra-class"><pre><code>无序的键值对的集合
使用内建函数 make 也可以使用 map 关键字来定义 Map

如果不初始化 map，那么就会创建一个 nil map。
nil map 不能用来存放键值对

声明一个map，默认为nil

delete(map, key)
</code></pre></div><h2 id="go-递归"><a href="#go-递归" class="header-anchor">#</a> Go 递归</h2> <div class="language- extra-class"><pre><code>阶乘
</code></pre></div><h2 id="go-类型转换"><a href="#go-类型转换" class="header-anchor">#</a> Go 类型转换</h2> <h2 id="go-接口"><a href="#go-接口" class="header-anchor">#</a> Go 接口</h2> <div class="language- extra-class"><pre><code>将所有共性的方法定义在一起，任何其他类型只要实现了这些方法
就是实现了这个接口
</code></pre></div><h2 id="go-错误处理"><a href="#go-错误处理" class="header-anchor">#</a> Go 错误处理</h2> <div class="language- extra-class"><pre><code>defer 语句调用是遵照先进后厨出的原则
</code></pre></div><h2 id="go-并发"><a href="#go-并发" class="header-anchor">#</a> Go 并发</h2> <div class="language- extra-class"><pre><code>goroutine
</code></pre></div><h2 id="go-内存分配"><a href="#go-内存分配" class="header-anchor">#</a> Go 内存分配</h2> <div class="language- extra-class"><pre><code>- new
- make  仅用于创建切片
</code></pre></div><h2 id="go-的主要特性"><a href="#go-的主要特性" class="header-anchor">#</a> GO 的主要特性</h2> <div class="language- extra-class"><pre><code>- 自动垃圾回收
- 丰富的内置类型
- 函数多返回值
- 错误处理
- 匿名函数和闭包
- 类型和接口
- 并发编程
- 反射
- 语言交互性
</code></pre></div><h1 id="运算符就是简单的-和-一个取地址、一个解析地址。"><a href="#运算符就是简单的-和-一个取地址、一个解析地址。" class="header-anchor">#</a> 运算符就是简单的 &amp; 和 * 一个取地址、一个解析地址。</h1> <h2 id="go的环境变量"><a href="#go的环境变量" class="header-anchor">#</a> go的环境变量</h2> <p>set GOARCH=amd64
set GOBIN=
set GOCACHE=C:\Users\Administrator\AppData\Local\go-build
set GOEXE=.exe
set GOFLAGS=
set GOHOSTARCH=amd64
set GOHOSTOS=windows
set GOOS=windows
set GOPATH=F:\goMoudule
set GOPROXY=
set GORACE=
set GOROOT=c:\go
set GOTMPDIR=
set GOTOOLDIR=c:\go\pkg\tool\windows_amd64
set GCCGO=gccgo
set CC=gcc
set CXX=g++
set CGO_ENABLED=1
set GOMOD=
set CGO_CFLAGS=-g -O2
set CGO_CPPFLAGS=
set CGO_CXXFLAGS=-g -O2
set CGO_FFLAGS=-g -O2
set CGO_LDFLAGS=-g -O2
set PKG_CONFIG=pkg-config
set GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\Users\ADMINI~1\AppData\Local\Temp\go-build595797562=/tmp/go-build -gno-record-gcc-switches</p> <h2 id="go-的channel-详解"><a href="#go-的channel-详解" class="header-anchor">#</a> go 的channel 详解</h2> <ul><li><p>基本使用
ch &lt;- v    // 发送值v到Channel ch中
v := &lt;-ch  // 从Channel ch中接收数据，并将数据赋值给v</p></li> <li><p>初始化
make(chan int, 100)   100 为容量 代表channel 的缓存大小
如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，
只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞，
而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p></li> <li><p>通讯</p></li></ul> <p>c := make(chan int)
defer close(c)
go func() { c &lt;- 3 + 4 }()
i := &lt;-c
fmt.Println(i)</p> <p>-- 接受数据
&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,
直到有数据可以接收。
从一个nil channel中接收数据会一直被block。</p> <p>从一个被close的channel中接收数据不会被阻塞，而是立即返回，
接收完已发送的数据后会返回元素类型的零值(zero value)。</p> <p>如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。
x, ok := &lt;-ch
x, ok = &lt;-ch
var x, ok = &lt;-ch</p> <p>-- select 语句
类似也switch  会选择一个send或者recive来执行</p> <p>-- Timer和Ticker</p> <p>timer是一个定时器，代表未来的一个单一事件
类似  setTimeOut
ticker
类似 setInterval</p> <p>类似timer, ticker也可以通过Stop方法来停止。一旦它停止，
接收者不再会从channel中接收数据了</p> <p>channel</p> <h2 id="go-进阶"><a href="#go-进阶" class="header-anchor">#</a> go 进阶</h2> <h2 id="init-函数详解"><a href="#init-函数详解" class="header-anchor">#</a> init 函数详解</h2> <p>###　go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性，</p> <p>1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</p> <p>2 每个包可以拥有多个init函数</p> <p>3 包的每个源文件也可以拥有多个init函数</p> <p>4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</p> <p>5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</p> <p>6 init函数不能被其他函数调用，而是在 main函数执行之前，自动被调用</p> <p>###　一个go程序的执行顺序</p> <p>变量初始化-&gt;init()-&gt;main()</p> <h3 id="若只想执行包中的init函数，而不使用包导出的变量和函数-可用-import"><a href="#若只想执行包中的init函数，而不使用包导出的变量和函数-可用-import" class="header-anchor">#</a> 若只想执行包中的init函数，而不使用包导出的变量和函数 可用 import _</h3> <h2 id="结构体的赋值和初始化"><a href="#结构体的赋值和初始化" class="header-anchor">#</a> 结构体的赋值和初始化</h2> <p>type Member struct {
name string
}</p> <p>var m1 *Member
m1.name = &quot;小明&quot;//错误用法，未初始化,m1为nil</p> <p>m1 = &amp;Member{}
m1.name = &quot;小明&quot;//初始化后，结构体指针指向某个结构体地址，才能访问字段，为字段赋值。
或者
var m2 = new(Member)
m2.name = &quot;小红&quot;</p> <h2 id="结构体不能包含自己"><a href="#结构体不能包含自己" class="header-anchor">#</a> 结构体不能包含自己</h2> <p>一个结构体，并没有包含自身，比如Member中的字段不能是Member类型，但却可能是*Member。</p> <h2 id="interface-的解释"><a href="#interface-的解释" class="header-anchor">#</a> interface{} 的解释</h2> <p>1 空接口类型interface{}一个方法签名也不包含，所以所有的数据类型都实现了该方法。
2 空接口类型在描述一个对象实例的行为上力不从心，但是当我们需要存储任意数据类型的
实例的时候，空接口类型的使用使得我们得心应手。
通俗的理解： 如果一个函数的参数包括空接口类型interface{}，实际上函数是在说“兄弟，我接受任何数据”。
如果一个函数返回一个空接口类型，那么函数再说“我也不确定返回什么，你只要知道我一定返回一个值就好了”。</p> <h2 id="不同平台go-build-的参数变化"><a href="#不同平台go-build-的参数变化" class="header-anchor">#</a> 不同平台go build 的参数变化</h2> <h3 id="编译linux"><a href="#编译linux" class="header-anchor">#</a> 编译linux</h3> <p>命令参数 GOOS=linux;CGO_ENABLED=1</p> <h3 id="编译window"><a href="#编译window" class="header-anchor">#</a> 编译window</h3> <p>命令参数 GOOS=windows;CGO_ENABLED=0</p> <p>​	
​	
​</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/oort_vuepress/assets/js/app.87766072.js" defer></script><script src="/oort_vuepress/assets/js/2.1e38d289.js" defer></script><script src="/oort_vuepress/assets/js/7.792cc8de.js" defer></script>
  </body>
</html>
