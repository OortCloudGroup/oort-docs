(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{357:function(a,t,s){"use strict";s.r(t);var e=s(43),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"go的web框架了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go的web框架了解"}},[a._v("#")]),a._v(" Go的web框架了解")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/dev_csdn/article/details/78740990",target:"_blank",rel:"noopener noreferrer"}},[a._v("csdn Go web 框架对比"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"环境安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环境安装"}},[a._v("#")]),a._v(" 环境安装")]),a._v(" "),s("h2",{attrs:{id:"使用goland-编译第一个go程序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用goland-编译第一个go程序"}},[a._v("#")]),a._v(" 使用goland 编译第一个Go程序")]),a._v(" "),s("p",[a._v("package main")]),a._v(" "),s("p",[a._v('import "fmt"')]),a._v(" "),s("p",[a._v('func main()  {\nfmt.Printf("hello world")\n}】')]),a._v(" "),s("h2",{attrs:{id:"go-语言结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-语言结构"}},[a._v("#")]),a._v(" Go 语言结构")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 包声明\n- 引入包\n- 函数\n- 变量\n- 语句 & 表达式\n- 注释\n")])])]),s("p",[a._v("注意： Go 语法中 { 不能单独一行")]),a._v(" "),s("p",[a._v("##　Go的基础语法")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- Go 标记 关键字 标识符 常量 字符串 符号 等 \n- 行分隔符号 一行代表一个语句结束\n- 注释\n- 标识符\n- 字符串连接  可以通过 + 实现\n- 关键字\n")])])]),s("h2",{attrs:{id:"go-数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-数据类型"}},[a._v("#")]),a._v(" Go 数据类型")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 布尔  false true\n- 数字类型 int  float32  float64 \n- 字符串类型\n- 派生类型 指针  数组 struct  channel 函数类型 切片类型\n\t接口类型  Map类型\n")])])]),s("h2",{attrs:{id:"数字类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数字类型"}},[a._v("#")]),a._v(" 数字类型")]),a._v(" "),s("h2",{attrs:{id:"go-语言变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-语言变量"}},[a._v("#")]),a._v(" Go 语言变量")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 由字母、数字、下划线， 首字母不能为数字\n- 声明变量 一般使用var \n")])])]),s("h2",{attrs:{id:"import-的特殊语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#import-的特殊语法"}},[a._v("#")]),a._v(" import 的特殊语法")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 点 . 操作\n- 别名操作\n- 下划线 _ 操作 导入该包，不导入整个包而是执行包中的init函数，注意init不需要调用就会执行\n")])])]),s("h2",{attrs:{id:"变量定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量定义"}},[a._v("#")]),a._v(" 变量定义")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('var variable_list data_type\n多变量可以同时赋值操作\n:= 表示声明变量并且赋值  #系统自动推断类型,不需要var关键字\n特殊变量 "_"  任何赋值 都会别丢弃 具体意义类似 \n\t_,numb,strs := numbers() //只获取函数返回值的后两个\n:= 左侧的变量不应该是已经被声明过的，否则会导致编译错误\n')])])]),s("h2",{attrs:{id:"值类型和引用类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#值类型和引用类型"}},[a._v("#")]),a._v(" 值类型和引用类型")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("通过 &i 来获取变量 i 的内存地址\n")])])]),s("p",[a._v("​")]),a._v(" "),s("h2",{attrs:{id:"go-语言常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-语言常量"}},[a._v("#")]),a._v(" Go 语言常量")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- const  可以用作枚举\n- iota const 中每新增一行常量声明将使 iota 计数一次 第一个 iota 等于 0\n")])])]),s("h2",{attrs:{id:"go-语言运算符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-语言运算符"}},[a._v("#")]),a._v(" Go 语言运算符")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 算术运算符  加减乘除\n- 关系运算符   < > <= >= != == \n- 逻辑运算符 && || ！\n- 位运算符 & | ^   >> << \n- \n- \n")])])]),s("h2",{attrs:{id:"go-条件-语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-条件-语句"}},[a._v("#")]),a._v(" Go 条件 语句")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("-if if...else  \n- switch  fallthrough 强行执行之后的case语句\n\t不同的 case 之间不使用 break 分隔 默认只执行一个case\n- select\n\tselect 会循环检测条件，如果有满足则执行并退出，\n\t否则一直循环检测。\n")])])]),s("h2",{attrs:{id:"循环语句"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环语句"}},[a._v("#")]),a._v(" 循环语句")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- for   break continue goto\n- 实现九九乘法表\n")])])]),s("h2",{attrs:{id:"go-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-函数"}},[a._v("#")]),a._v(" Go 函数")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- Go 语言最少有个 main() 函数\n- 闭包\n- 函数作为一个参数\n- 函数声明  type cb func(int) int\n- 返回多个值\n- 不定参数\n")])])]),s("h2",{attrs:{id:"go-变量的作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-变量的作用域"}},[a._v("#")]),a._v(" Go 变量的作用域")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 局部变量\n- 全局变量\n- 形参\n")])])]),s("h2",{attrs:{id:"go-数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-数组"}},[a._v("#")]),a._v(" Go 数组")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 声明需要指定元素类型及其个数\n")])])]),s("h2",{attrs:{id:"go-指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-指针"}},[a._v("#")]),a._v(" Go 指针")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 一个指针变量指向了一个值的内存地址。\n- 声明指针 var-type 为指针类型\n- var p *int \n")])])]),s("h2",{attrs:{id:"go-结构体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-结构体"}},[a._v("#")]),a._v(" Go 结构体")]),a._v(" "),s("h2",{attrs:{id:"go-切片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-切片"}},[a._v("#")]),a._v(" Go 切片")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('make函数创建切片 内置类型切片("动态数组"),\n\nmake([]int,3,5)\nlen = 3 cap = 5\n\n如果要增加切片的容量，必须创建一个新的更大\n的切片并把原分片的内容都拷贝过来\n')])])]),s("h2",{attrs:{id:"go-语言范围"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-语言范围"}},[a._v("#")]),a._v(" Go 语言范围")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("range 用于for循环中迭代数组，切片，通道或者map的元素\n\n相当于 for in\n")])])]),s("h2",{attrs:{id:"go-map-集合"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-map-集合"}},[a._v("#")]),a._v(" Go Map 集合")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("无序的键值对的集合\n使用内建函数 make 也可以使用 map 关键字来定义 Map\n\n如果不初始化 map，那么就会创建一个 nil map。\nnil map 不能用来存放键值对\n\n声明一个map，默认为nil\n\ndelete(map, key)\n")])])]),s("h2",{attrs:{id:"go-递归"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-递归"}},[a._v("#")]),a._v(" Go 递归")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("阶乘\n")])])]),s("h2",{attrs:{id:"go-类型转换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-类型转换"}},[a._v("#")]),a._v(" Go 类型转换")]),a._v(" "),s("h2",{attrs:{id:"go-接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-接口"}},[a._v("#")]),a._v(" Go 接口")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("将所有共性的方法定义在一起，任何其他类型只要实现了这些方法\n就是实现了这个接口\n")])])]),s("h2",{attrs:{id:"go-错误处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-错误处理"}},[a._v("#")]),a._v(" Go 错误处理")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("defer 语句调用是遵照先进后厨出的原则\n")])])]),s("h2",{attrs:{id:"go-并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-并发"}},[a._v("#")]),a._v(" Go 并发")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("goroutine\n")])])]),s("h2",{attrs:{id:"go-内存分配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-内存分配"}},[a._v("#")]),a._v(" Go 内存分配")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- new\n- make  仅用于创建切片\n")])])]),s("h2",{attrs:{id:"go-的主要特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-的主要特性"}},[a._v("#")]),a._v(" GO 的主要特性")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("- 自动垃圾回收\n- 丰富的内置类型\n- 函数多返回值\n- 错误处理\n- 匿名函数和闭包\n- 类型和接口\n- 并发编程\n- 反射\n- 语言交互性\n")])])]),s("h1",{attrs:{id:"运算符就是简单的-和-一个取地址、一个解析地址。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运算符就是简单的-和-一个取地址、一个解析地址。"}},[a._v("#")]),a._v(" 运算符就是简单的 & 和 * 一个取地址、一个解析地址。")]),a._v(" "),s("h2",{attrs:{id:"go的环境变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go的环境变量"}},[a._v("#")]),a._v(" go的环境变量")]),a._v(" "),s("p",[a._v("set GOARCH=amd64\nset GOBIN=\nset GOCACHE=C:\\Users\\Administrator\\AppData\\Local\\go-build\nset GOEXE=.exe\nset GOFLAGS=\nset GOHOSTARCH=amd64\nset GOHOSTOS=windows\nset GOOS=windows\nset GOPATH=F:\\goMoudule\nset GOPROXY=\nset GORACE=\nset GOROOT=c:\\go\nset GOTMPDIR=\nset GOTOOLDIR=c:\\go\\pkg\\tool\\windows_amd64\nset GCCGO=gccgo\nset CC=gcc\nset CXX=g++\nset CGO_ENABLED=1\nset GOMOD=\nset CGO_CFLAGS=-g -O2\nset CGO_CPPFLAGS=\nset CGO_CXXFLAGS=-g -O2\nset CGO_FFLAGS=-g -O2\nset CGO_LDFLAGS=-g -O2\nset PKG_CONFIG=pkg-config\nset GOGCCFLAGS=-m64 -mthreads -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\go-build595797562=/tmp/go-build -gno-record-gcc-switches")]),a._v(" "),s("h2",{attrs:{id:"go-的channel-详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-的channel-详解"}},[a._v("#")]),a._v(" go 的channel 详解")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("基本使用\nch <- v    // 发送值v到Channel ch中\nv := <-ch  // 从Channel ch中接收数据，并将数据赋值给v")])]),a._v(" "),s("li",[s("p",[a._v("初始化\nmake(chan int, 100)   100 为容量 代表channel 的缓存大小\n如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，\n只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞，\n而只有缓存空了后receive才会阻塞。一个nil channel不会通信。")])]),a._v(" "),s("li",[s("p",[a._v("通讯")])])]),a._v(" "),s("p",[a._v("c := make(chan int)\ndefer close(c)\ngo func() { c <- 3 + 4 }()\ni := <-c\nfmt.Println(i)")]),a._v(" "),s("p",[a._v("-- 接受数据\n<-ch用来从channel ch中接收数据，这个表达式会一直被block,\n直到有数据可以接收。\n从一个nil channel中接收数据会一直被block。")]),a._v(" "),s("p",[a._v("从一个被close的channel中接收数据不会被阻塞，而是立即返回，\n接收完已发送的数据后会返回元素类型的零值(zero value)。")]),a._v(" "),s("p",[a._v("如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。\nx, ok := <-ch\nx, ok = <-ch\nvar x, ok = <-ch")]),a._v(" "),s("p",[a._v("-- select 语句\n类似也switch  会选择一个send或者recive来执行")]),a._v(" "),s("p",[a._v("-- Timer和Ticker")]),a._v(" "),s("p",[a._v("timer是一个定时器，代表未来的一个单一事件\n类似  setTimeOut\nticker\n类似 setInterval")]),a._v(" "),s("p",[a._v("类似timer, ticker也可以通过Stop方法来停止。一旦它停止，\n接收者不再会从channel中接收数据了")]),a._v(" "),s("p",[a._v("channel")]),a._v(" "),s("h2",{attrs:{id:"go-进阶"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#go-进阶"}},[a._v("#")]),a._v(" go 进阶")]),a._v(" "),s("h2",{attrs:{id:"init-函数详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#init-函数详解"}},[a._v("#")]),a._v(" init 函数详解")]),a._v(" "),s("p",[a._v("###　go语言中init函数用于包(package)的初始化，该函数是go语言的一个重要特性，")]),a._v(" "),s("p",[a._v("1 init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等")]),a._v(" "),s("p",[a._v("2 每个包可以拥有多个init函数")]),a._v(" "),s("p",[a._v("3 包的每个源文件也可以拥有多个init函数")]),a._v(" "),s("p",[a._v("4 同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)")]),a._v(" "),s("p",[a._v("5 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序")]),a._v(" "),s("p",[a._v("6 init函数不能被其他函数调用，而是在 main函数执行之前，自动被调用")]),a._v(" "),s("p",[a._v("###　一个go程序的执行顺序")]),a._v(" "),s("p",[a._v("变量初始化->init()->main()")]),a._v(" "),s("h3",{attrs:{id:"若只想执行包中的init函数，而不使用包导出的变量和函数-可用-import"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#若只想执行包中的init函数，而不使用包导出的变量和函数-可用-import"}},[a._v("#")]),a._v(" 若只想执行包中的init函数，而不使用包导出的变量和函数 可用 import _")]),a._v(" "),s("h2",{attrs:{id:"结构体的赋值和初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结构体的赋值和初始化"}},[a._v("#")]),a._v(" 结构体的赋值和初始化")]),a._v(" "),s("p",[a._v("type Member struct {\nname string\n}")]),a._v(" "),s("p",[a._v('var m1 *Member\nm1.name = "小明"//错误用法，未初始化,m1为nil')]),a._v(" "),s("p",[a._v('m1 = &Member{}\nm1.name = "小明"//初始化后，结构体指针指向某个结构体地址，才能访问字段，为字段赋值。\n或者\nvar m2 = new(Member)\nm2.name = "小红"')]),a._v(" "),s("h2",{attrs:{id:"结构体不能包含自己"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结构体不能包含自己"}},[a._v("#")]),a._v(" 结构体不能包含自己")]),a._v(" "),s("p",[a._v("一个结构体，并没有包含自身，比如Member中的字段不能是Member类型，但却可能是*Member。")]),a._v(" "),s("h2",{attrs:{id:"interface-的解释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#interface-的解释"}},[a._v("#")]),a._v(" interface{} 的解释")]),a._v(" "),s("p",[a._v("1 空接口类型interface{}一个方法签名也不包含，所以所有的数据类型都实现了该方法。\n2 空接口类型在描述一个对象实例的行为上力不从心，但是当我们需要存储任意数据类型的\n实例的时候，空接口类型的使用使得我们得心应手。\n通俗的理解： 如果一个函数的参数包括空接口类型interface{}，实际上函数是在说“兄弟，我接受任何数据”。\n如果一个函数返回一个空接口类型，那么函数再说“我也不确定返回什么，你只要知道我一定返回一个值就好了”。")]),a._v(" "),s("h2",{attrs:{id:"不同平台go-build-的参数变化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同平台go-build-的参数变化"}},[a._v("#")]),a._v(" 不同平台go build 的参数变化")]),a._v(" "),s("h3",{attrs:{id:"编译linux"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译linux"}},[a._v("#")]),a._v(" 编译linux")]),a._v(" "),s("p",[a._v("命令参数 GOOS=linux;CGO_ENABLED=1")]),a._v(" "),s("h3",{attrs:{id:"编译window"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#编译window"}},[a._v("#")]),a._v(" 编译window")]),a._v(" "),s("p",[a._v("命令参数 GOOS=windows;CGO_ENABLED=0")]),a._v(" "),s("p",[a._v("​\t\n​\t\n​")])])}),[],!1,null,null,null);t.default=n.exports}}]);